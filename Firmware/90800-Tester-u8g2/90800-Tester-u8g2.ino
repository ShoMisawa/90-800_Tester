#include <U8g2lib.h>


//#include <Beastdevices_INA3221.h>
#include <Wire.h>

#include <SPI.h>

U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE); // initialization for the used OLED display

// images from https://lopaka.app/
static const unsigned char image_Voltage_16x16_bits[] U8X8_PROGMEM = {0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x03,0x80,0x01,0xc0,0x01,0xe0,0x00,0xf0,0x07,0x80,0x03,0xc0,0x01,0xc0,0x00,0x60,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_icons8_outline_effect_tickmark_under_a_square_box_24_bits[] U8X8_PROGMEM = {0xfe,0xff,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0xff,0x7f,0xf0,0xff,0x3f,0xf0,0xff,0x1f,0xf0,0xff,0x1f,0xf8,0xff,0x0f,0xfc,0x1f,0x07,0xfe,0x0f,0x02,0xff,0x0f,0x00,0xff,0x0f,0x80,0xff,0x1f,0xc0,0xff,0x7f,0xe0,0xff,0xff,0xf0,0xff,0xff,0xf1,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xff,0x7f};
static const unsigned char image_icons8_switch_24__1__bits[] U8X8_PROGMEM = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0xff,0x07,0xf8,0xff,0x1f,0x1c,0x00,0x38,0x0c,0x80,0x37,0x06,0xc0,0x6f,0x06,0xc0,0x6f,0x06,0xc0,0x6f,0x06,0xc0,0x6f,0x0c,0x80,0x37,0x1c,0x00,0x38,0xf8,0xff,0x1f,0xe0,0xff,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_icons8_switch_24_bits[] U8X8_PROGMEM = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0xff,0x07,0xf8,0xff,0x1f,0x1c,0xfe,0x3f,0x0c,0xfc,0x3f,0x06,0xf8,0x7f,0x06,0xf8,0x7f,0x06,0xf8,0x7f,0x06,0xf8,0x7f,0x0c,0xfc,0x3f,0x1c,0xfe,0x3f,0xf8,0xff,0x1f,0xe0,0xff,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_icons8_cross_48_bits[] U8X8_PROGMEM = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0x7f,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x80,0xff,0xff,0xff,0xff,0x01,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0x7f,0xfc,0x3f,0xfe,0x03,0xc0,0x7f,0xf8,0x1f,0xfe,0x03,0xc0,0x7f,0xf0,0x0f,0xfe,0x03,0xc0,0xff,0xe0,0x07,0xff,0x03,0xc0,0xff,0xc1,0x83,0xff,0x03,0xc0,0xff,0x83,0xc1,0xff,0x03,0xc0,0xff,0x07,0xe0,0xff,0x03,0xc0,0xff,0x0f,0xf0,0xff,0x03,0xc0,0xff,0x1f,0xf8,0xff,0x03,0xc0,0xff,0x1f,0xf8,0xff,0x03,0xc0,0xff,0x0f,0xf0,0xff,0x03,0xc0,0xff,0x07,0xe0,0xff,0x03,0xc0,0xff,0x83,0xc1,0xff,0x03,0xc0,0xff,0xc1,0x83,0xff,0x03,0xc0,0xff,0xe0,0x07,0xff,0x03,0xc0,0x7f,0xf0,0x0f,0xfe,0x03,0xc0,0x7f,0xf8,0x1f,0xfe,0x03,0xc0,0x7f,0xfc,0x3f,0xfe,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0xc0,0xff,0xff,0xff,0xff,0x03,0x80,0xff,0xff,0xff,0xff,0x01,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0xfe,0xff,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_detex_bits[] U8X8_PROGMEM = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xff,0x00,0xf0,0xff,0xff,0xff,0xff,0xff,0xcf,0x0f,0xc0,0x03,0xf0,0xff,0x0f,0xf0,0xff,0xff,0xff,0xff,0xff,0xcf,0x3f,0xf8,0x03,0xf0,0xff,0x0f,0xf0,0xff,0xff,0xff,0xff,0xff,0xcf,0x3f,0xf8,0x03,0xf0,0xff,0x3f,0xfc,0xff,0xff,0xff,0xff,0xff,0x0f,0x3f,0xfe,0x00,0xf0,0xff,0x3f,0xf8,0xff,0xff,0xff,0xff,0xff,0x0f,0x3f,0xfe,0x00,0xf0,0x03,0x7f,0x00,0x00,0xc0,0x3f,0x00,0x00,0x00,0xff,0x3f,0x00,0xf0,0x03,0x7f,0x00,0x00,0xc0,0x3f,0x00,0x00,0x00,0xfe,0x3f,0x00,0xfc,0x01,0x7f,0xfc,0xff,0xc0,0x3f,0xf0,0xff,0x03,0xfc,0x1f,0x00,0xfc,0x00,0x7f,0xfc,0xff,0xc0,0x3f,0xf0,0xff,0x03,0xfc,0x0f,0x00,0xfc,0x00,0x7f,0xfe,0xff,0xc0,0x1f,0xf0,0xff,0x03,0xfc,0x0f,0x00,0xfc,0x00,0x3f,0xfe,0xff,0xc0,0x0f,0xf0,0xff,0x03,0xfc,0x0f,0x00,0xfc,0x00,0x3f,0x00,0x00,0xc0,0x0f,0x00,0x00,0x00,0xff,0x0f,0x00,0xfc,0x00,0x3f,0x00,0x00,0xc0,0x0f,0x00,0x00,0x00,0xff,0x0f,0x00,0xfc,0xc0,0x3f,0x00,0x00,0xf0,0x0f,0x00,0x00,0xc0,0xff,0x1f,0x00,0xfc,0xc0,0x1f,0x00,0x00,0xf0,0x0f,0x00,0x00,0xc0,0xcf,0x1f,0x00,0xff,0xff,0x0f,0xff,0x3f,0xf0,0x0f,0xfc,0xff,0xf0,0x0f,0x3f,0x00,0xff,0xff,0x8f,0xff,0x3f,0xf0,0x0f,0xfc,0xff,0xf0,0x07,0x3f,0x00,0xff,0xff,0xc1,0xff,0x3f,0xf0,0x07,0xfc,0xff,0xfc,0x01,0x3f,0x00,0xff,0xff,0xc0,0xff,0x3f,0xf0,0x07,0xfc,0xff,0xfc,0x01,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_icons8_reset_24_bits[] U8X8_PROGMEM = {0x00,0x00,0x00,0x00,0x3c,0x0c,0x80,0xff,0x0f,0xe0,0xff,0x0f,0xf0,0x81,0x0f,0x78,0xc0,0x0f,0x38,0xe0,0x0f,0x1c,0x00,0x00,0x1c,0x00,0x00,0x0c,0x00,0x00,0x0e,0x00,0x00,0x0e,0x00,0x20,0x04,0x00,0x70,0x00,0x00,0x70,0x00,0x00,0x30,0x00,0x00,0x38,0x00,0x00,0x38,0xf0,0x07,0x1c,0xf0,0x03,0x1e,0xf0,0x81,0x0f,0xf0,0xff,0x07,0xf0,0xff,0x01,0x30,0x3c,0x00,0x00,0x00,0x00};
static const unsigned char image_icons8_sad_24_bits[] U8X8_PROGMEM = {0x00,0x7e,0x60,0xc0,0xff,0xf3,0xe6,0x81,0xf3,0x4f,0x00,0x78,0x0f,0x00,0x18,0x0e,0x66,0x00,0x88,0xe7,0x61,0xc0,0x81,0x63,0xe2,0x00,0x67,0x03,0x3c,0xc0,0x03,0xff,0xc0,0x83,0xff,0xc1,0x83,0xff,0xc1,0xc3,0xff,0xc3,0xc3,0x00,0xc3,0x06,0x00,0x60,0x06,0x00,0x60,0x0e,0x00,0x70,0x0c,0x00,0x30,0x18,0x00,0x18,0x70,0x00,0x0e,0xe0,0x81,0x07,0xc0,0xff,0x03,0x00,0x7e,0x00};


#define ONE_WIRE_BUS 10

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)

#define UI_BMPWIDTH  128

#define upperLimit 24*(1+0.1)
#define lowerLimit 24*(1-0.1)

#define LED_8                8
#define LED_9                9
#define LED_10               10
#define Relay                7
#define Button               2
#define voltageDisplayToggle 3

#define LED_TEST_MODE        0

float R1 = 100000;
float R2 = 10000;
float resRatio = R2 / (R1 + R2);

// Bot J6
float adc_voltage = 0.0;
float in_voltage = 0.0;
float ref_voltage = 3.3;
int adc_value = 0;

// Top J9
float adc_voltage_2 = 0.0;
float in_voltage_2 = 0.0;
int adc_value_2 = 0;

int voltageValidation_1 = 0;
int voltageValidation_2 = 0;

int voltageDetected = 0; // upon power connection to 24V, this flag is set to 0 when it is less than 15V.  Set to 1 when it is greater than 15V.  15V is random value.

int state = 0;

//unsigned long previousMillis;
int count = 1; // for development purpose, it is set to the state

int relayActiveFlag = 0;
int powerDetectionOK = 0;
int VoltageTestOK = 0;
int FLTestOK = 0;

char buffer[32];

bool iconVisible = true; // default should be true
bool voltageCheckVisible = false; // default should be false
bool relaySwitchVisible = true; // default should be true

const long interval = 1000; // Flash interval for the icon in millisecond
unsigned long previousMillis = 0;
unsigned long currentMillis = 0;
char voltagebuffer[32]; // helper buffer to construct a string to be displayed


void setup() {

  pinMode(Button, INPUT_PULLUP); // this line also has external pullup resistor
  pinMode(voltageDisplayToggle, INPUT_PULLUP); // this line also has external pullup resistor
  pinMode(LED_8, OUTPUT);
  pinMode(LED_9, OUTPUT);
  pinMode(LED_10, OUTPUT);
  pinMode(Relay, OUTPUT);
  // pinMode(A0, INPUT);
  // pinMode(A1, INPUT);
  
  digitalWrite(LED_8, LOW);
  digitalWrite(LED_9, LOW);
  digitalWrite(LED_10, LOW);
  digitalWrite(Relay, HIGH);

  // SSD1306 Initialization...
  Serial.begin(9600);
  Serial.println("Starting up ...");

  u8g2.begin(); // start the u8g2 library...
  u8g2.clearBuffer();
  u8g2.setBitmapMode(1);
  u8g2.drawXBMP( 15, -1, 100, 70, image_detex_bits);
  u8g2.sendBuffer();
  delay(1000); // One second splash screen

  analogReadResolution(12);

}

void loop() {

  if(LED_TEST_MODE == 1){
    digitalWrite(LED_8, HIGH);
    digitalWrite(LED_9, HIGH);
    digitalWrite(LED_10, HIGH);
  }else{

  // J2 on the tester PWA
  adc_value = analogRead(0);
  adc_voltage = (adc_value * ref_voltage) / 4095.0;
  in_voltage = (adc_voltage / resRatio) + 0.3; // 0.3 is for schottky diode voltage adjustment

  // J4 on the tester PWA
  adc_value_2 = analogRead(1);
  adc_voltage_2 = (adc_value_2 * ref_voltage) / 4095.0;
  in_voltage_2 = (adc_voltage_2 / resRatio) + 0.3; // 0.3 is for schottky diode voltage adjustment

  switch(state){
    case 0: // Waiting for 24V to come in... Upon detection move to the next case

      // Waiting until voltage readings become higher than 15VDC
      while ((in_voltage < 15 || in_voltage_2 < 15)){
        // J2 on the tester PWA
        adc_value = analogRead(0);
        adc_voltage = (adc_value * ref_voltage) / 4095.0;
        in_voltage = (adc_voltage / resRatio) + 0.3; // 0.3 is for schottky diode voltage adjustment

        // J4 on the tester PWA
        adc_value_2 = analogRead(1);
        adc_voltage_2 = (adc_value_2 * ref_voltage) / 4095.0;
        in_voltage_2 = (adc_voltage_2 / resRatio) + 0.3; // 0.3 is for schottky diode voltage adjustment
        
        u8g2.clearBuffer();
        u8g2.setBitmapMode(1);
        u8g2.drawFrame(2, 2, 123, 61);
        u8g2.setFont(u8g2_font_helvB08_tr);
        u8g2.drawStr(17, 29, "Waiting for Power");
        //u8g2.drawBox(56, 35, 13, 15);
        u8g2.drawXBMP( 55, 35, 16, 16, image_Voltage_16x16_bits);
//        if(iconVisible == true){
//          u8g2.drawXBMP( 55, 35, 16, 16, image_Voltage_16x16_bits);
//        }else{
//          u8g2.setDrawColor(0);
//          u8g2.drawBox(56, 35, 13, 15);
//          u8g2.setDrawColor(1);
//        }
        
        u8g2.sendBuffer();          // transfer internal memory to the display
//    }

      } 
      
//      preDisplay(3, 0, 0);
//      display.println("   Power");
//      display.println("  Detected");
//      display.display();
      delay(1000);
      
      voltageDetected = 1; // after coming out from the while loop, the voltage should be greater than 15VDC
      state = 1;

    break;

    case 1: // Power detected... Transition into voltage confirmation
      
      powerDetectionOK = 1;
      state = 2;
      digitalWrite(LED_8, HIGH);
      
      // After voltage detected and voltage drops below 15V, it will go back to state 0
      if (in_voltage < 15 || in_voltage_2 < 15){
        state = 0;
        digitalWrite(LED_8, LOW);
      }
      
    break;

    case 2: // Showing voltage reading on OLED and waiting for confirmation button to be pressed
      // Waiting for the confirmation by pressing the button located on the right hand bottom side
      while(!digitalRead(Button) == LOW){
          adc_value = analogRead(0);
          adc_voltage = (adc_value * ref_voltage) / 4095.0;
          in_voltage = (adc_voltage / resRatio) + 0.3; // 0.3 is for schottky diode voltage adjustment

          // J4 on the tester PWA
          adc_value_2 = analogRead(1);
          adc_voltage_2 = (adc_value_2 * ref_voltage) / 4095.0;
          in_voltage_2 = (adc_voltage_2 / resRatio) + 0.3; // 0.3 is for schottky diode voltage adjustment

          u8g2.setBitmapMode(1);
          u8g2.clearBuffer(); 
          u8g2.drawFrame(2, 2, 124, 62);
          u8g2.drawLine(3, 15, 125, 15);
          u8g2.setFont(u8g2_font_haxrcorp4089_tr);
          //u8g2.drawStr(27, 30, "J6:");
          u8g2.setFont(u8g2_font_haxrcorp4089_tr);
          sprintf(voltagebuffer,"J6: %.2f", in_voltage);
          u8g2.drawStr(27, 30, voltagebuffer);
          u8g2.setFont(u8g2_font_haxrcorp4089_tr);
          u8g2.drawStr(83, 30, "V");
          u8g2.setFont(u8g2_font_haxrcorp4089_tr);
          u8g2.drawStr(30, 13, "Voltage Reading");
          u8g2.setFont(u8g2_font_haxrcorp4089_tr);
          //u8g2.drawStr(27, 45, "J7:");
          u8g2.setFont(u8g2_font_haxrcorp4089_tr);
          sprintf(voltagebuffer, "J7: %.2f", in_voltage_2);
          u8g2.drawStr(27, 45, voltagebuffer);
          u8g2.setFont(u8g2_font_haxrcorp4089_tr);
          u8g2.drawStr(83, 45, "V");
          if (in_voltage < upperLimit && in_voltage > lowerLimit)
            u8g2.drawXBMP( 99, 38, 24, 24, image_icons8_outline_effect_tickmark_under_a_square_box_24_bits);
          else{
            u8g2.setDrawColor(0);
            u8g2.drawBox(97, 36, 27, 26);
            u8g2.setDrawColor(1);
            voltageCheckVisible = false;
          }
          u8g2.sendBuffer();

          if (in_voltage < upperLimit && in_voltage > lowerLimit) {
            voltageValidation_1 = 1;
            voltageValidation_2 = 1;
            digitalWrite(LED_9,HIGH);
          } else {
            voltageValidation_1 = 0;
            voltageValidation_2 = 0;
            digitalWrite(LED_9,LOW);
          } 

          if ( voltageValidation_1 == 1 && voltageValidation_2 == 1) {
          VoltageTestOK = 1;
          digitalWrite(LED_9, HIGH);
          state = 3;
        } else {
          digitalWrite(LED_9, LOW);
        }
      }
    break;

    case 3: // Turning off relay for FL test
            u8g2.setBitmapMode(1);
            u8g2.clearBuffer(); 
        
            u8g2.drawFrame(2, 2, 125, 61);
            u8g2.drawLine(2, 14, 126, 14);
            u8g2.setFont(u8g2_font_haxrcorp4089_tr);
            u8g2.drawStr(51, 30, "Relay");
            u8g2.setFont(u8g2_font_haxrcorp4089_tr);
            u8g2.drawStr(33, 12, "Fire Loop Test");
            u8g2.drawXBMP( 50, 34, 24, 24, image_icons8_switch_24__1__bits);
            u8g2.sendBuffer();
            digitalWrite(Relay,LOW);
              
//            if (relaySwitchVisible == true){
//              u8g2.drawXBMP( 50, 34, 24, 24, image_icons8_switch_24_bits);
//              u8g2.sendBuffer();  
//              delay(500); // half second delay
//
//              relaySwitchVisible = false;
//        
//            }else{
//              u8g2.drawXBMP( 50, 34, 24, 24, image_icons8_switch_24__1__bits);
//              u8g2.sendBuffer();  
//        
//              // Add relay pin change
//              digitalWrite(Relay,LOW);
//              relaySwitchVisible = true;
//            }
            relayActiveFlag = 1;
            delay(1000);
            state = 4;
        break;
        
        case 4: // Fire loop test            
        if (relayActiveFlag == 1){
          // Resetting the voltageValidation for fire loop detection
          voltageValidation_1 = 0;
          voltageValidation_2 = 0;

          if (in_voltage < 10 || in_voltage_2 < 10){
            voltageValidation_1 = 1;
            voltageValidation_2 = 1;
          }else{
            voltageValidation_1 = 0;
            voltageValidation_2 = 0;
          }
          
          if ( voltageValidation_1 == 1 && voltageValidation_2 == 1) {
            u8g2.setBitmapMode(1);
            u8g2.clearBuffer(); 
            u8g2.drawFrame(2, 3, 125, 61);
            u8g2.setFont(u8g2_font_haxrcorp4089_tr);
            u8g2.drawStr(33, 12, "Fire Loop Test");
            u8g2.drawLine(2, 14, 126, 14);
            u8g2.drawXBMP( 51, 26, 24, 24, image_icons8_outline_effect_tickmark_under_a_square_box_24_bits);
            u8g2.sendBuffer();
            delay(1000);
            FLTestOK = 1;
            digitalWrite(LED_10, HIGH);
            digitalWrite(Relay, HIGH);
            relayActiveFlag = 0;
            state = 5;
          } else {
//            preDisplay(3, 0, 0);
//            display.println("    FL");
//            display.println("    BAD");
//            display.display();
            delay(1000);
            digitalWrite(LED_10, LOW);
            state = 5;
          } 
        }
        break;
        
        case 5: // Test Result

          // while toggle switch is in the LOW state, display the output voltage reading.
          while (!digitalRead(voltageDisplayToggle) == LOW){
              in_voltage = voltMeasure(0);
              in_voltage_2 = voltMeasure(1);

              u8g2.setBitmapMode(1);
              u8g2.clearBuffer(); 
              u8g2.drawFrame(2, 2, 124, 62);
              u8g2.drawLine(3, 15, 125, 15);
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              //u8g2.drawStr(27, 30, "J6:");
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              sprintf(voltagebuffer,"J6: %.2f", in_voltage);
              u8g2.drawStr(27, 30, voltagebuffer);
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              u8g2.drawStr(83, 30, "V");
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              u8g2.drawStr(30, 13, "Voltage Reading");
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              //u8g2.drawStr(27, 45, "J7:");
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              sprintf(voltagebuffer, "J7: %.2f", in_voltage_2);
              u8g2.drawStr(27, 45, voltagebuffer);
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              u8g2.drawStr(83, 45, "V");
              if (in_voltage < upperLimit && in_voltage > lowerLimit)
                u8g2.drawXBMP( 99, 38, 24, 24, image_icons8_outline_effect_tickmark_under_a_square_box_24_bits);
              else{
                u8g2.setDrawColor(0);
                u8g2.drawBox(97, 36, 27, 26);
                u8g2.setDrawColor(1);
                voltageCheckVisible = false;
              }
              u8g2.sendBuffer();
          }
          
          if (VoltageTestOK == 1 && FLTestOK == 1 && powerDetectionOK == 1){

              u8g2.setBitmapMode(1);
              u8g2.clearBuffer(); 
              u8g2.drawFrame(2, 3, 125, 61);
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              u8g2.drawStr(40, 12, "All Test OK");
              u8g2.drawLine(2, 14, 126, 14);
              u8g2.drawXBMP( 51, 26, 24, 24, image_icons8_outline_effect_tickmark_under_a_square_box_24_bits);
              u8g2.sendBuffer();  
            ////delay(5000);
            in_voltage = voltMeasure(0);
            in_voltage_2 = voltMeasure(1);
            if(in_voltage < 20 || in_voltage_2 < 20){
              u8g2.clearBuffer();
              u8g2.setBitmapMode(1);
              u8g2.drawFrame(2, 2, 125, 61);
              u8g2.drawXBMP( 51, 11, 24, 24, image_icons8_reset_24_bits);
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              u8g2.drawStr(40, 49, "RESETTING...");
              u8g2.sendBuffer();
              delay(2000);
              resetParameters();
            }
          }else if(VoltageTestOK == 0 && FLTestOK == 1 && powerDetectionOK == 1){
            // Test Failed
            u8g2.clearBuffer();  
            u8g2.setBitmapMode(1);
            u8g2.drawFrame(2, 2, 124, 62);
            u8g2.setFont(u8g2_font_haxrcorp4089_tr);
            u8g2.drawStr(33, 13, "Voltage Test");
            u8g2.drawLine(2, 14, 126, 14);
            u8g2.drawXBMP( 37, 15, 48, 48, image_icons8_cross_48_bits);
            u8g2.sendBuffer();
            delay(5000);
          }else if(VoltageTestOK == 1 && FLTestOK == 0 && powerDetectionOK == 1){
            // Test Failed
              u8g2.clearBuffer();  
              u8g2.setBitmapMode(1);
              u8g2.drawFrame(2, 2, 124, 62);
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              u8g2.drawStr(33, 13, "Fire Loop Test");
              u8g2.drawLine(2, 14, 126, 14);
              u8g2.drawXBMP( 37, 15, 48, 48, image_icons8_cross_48_bits);
              u8g2.sendBuffer();
//            delay(5000);
          }else if(VoltageTestOK == 1 && FLTestOK == 1 && powerDetectionOK == 0){
              u8g2.clearBuffer();  
              u8g2.setBitmapMode(1);
              u8g2.drawFrame(2, 2, 124, 62);
              u8g2.setFont(u8g2_font_haxrcorp4089_tr);
              u8g2.drawStr(20, 13, "Power Detection Test");
              u8g2.drawLine(2, 14, 126, 14);
              u8g2.drawXBMP( 37, 15, 48, 48, image_icons8_cross_48_bits);
              u8g2.sendBuffer();  
//            delay(5000);
          }else if(VoltageTestOK == 0 && FLTestOK == 0 && powerDetectionOK == 1){
            u8g2.clearBuffer();  
            u8g2.setBitmapMode(1);
            u8g2.drawFrame(2, 2, 124, 62);
            u8g2.setFont(u8g2_font_haxrcorp4089_tr);
            u8g2.drawStr(27, 13, "FL and VT Test");
            u8g2.drawLine(2, 14, 126, 14);
            u8g2.drawXBMP( 37, 15, 48, 48, image_icons8_cross_48_bits);
            u8g2.sendBuffer();
            //delay(5000);
          }else{
//            preDisplay(3, 0, 0);
//            display.println("    Test");
//            display.println("   Failed");
//            display.display();
            u8g2.clearBuffer();  

            u8g2.setBitmapMode(1);
            u8g2.drawFrame(2, 2, 125, 61);
            u8g2.setFont(u8g2_font_haxrcorp4089_tr);
            u8g2.drawStr(38, 49, "ALL FAILED");
            u8g2.drawXBMP( 50, 13, 24, 24, image_icons8_sad_24_bits);
                        
            u8g2.sendBuffer();


            //delay(5000);
          }
          
          
          //resetParameters();
          
          
        break;
  }
  }


} // End of main loop

void resetParameters(){
  voltageValidation_1 = 0;
  voltageValidation_2 = 0;
  
  voltageDetected = 0; // upon power connection to 24V, this flag is set to 0 when it is less than 15V.  Set to 1 when it is greater than 15V.  15V is random value.
  
  state = 0;
  
  previousMillis;
  count = 1; // for development purpose, it is set to the state
  
  relayActiveFlag = 0;
  powerDetectionOK = 0;
  VoltageTestOK = 0;
  FLTestOK = 0;

  digitalWrite(LED_8, LOW);
  digitalWrite(LED_9, LOW);
  digitalWrite(LED_10, LOW);
  digitalWrite(Relay,HIGH);
}

float voltMeasure(int channel) {
  analogReadResolution(12);
  
  if(channel == 0){
    
    adc_value = analogRead(channel);
    adc_voltage = (adc_value * ref_voltage) / 4095.0;
    in_voltage = adc_voltage / resRatio;
    return in_voltage;
    
  }

  if(channel == 1){
    
    adc_value_2 = analogRead(channel);
    adc_voltage_2 = (adc_value_2 * ref_voltage) / 4095.0;
    in_voltage_2 = adc_voltage_2 / resRatio;
    return in_voltage_2;

  }
  
} // end of voltMeter function

//void printDisplay(String string, float voltage) {
//  display.println(string);
//  display.print("  ");
//  display.print(voltage);
//  display.print(" V");
//  display.println();
//} // end of printDisplay
//
//void preDisplay(char textSize, int x, int y) {
//  display.clearDisplay();
//  display.setTextSize(2);
//  display.setTextColor(SSD1306_WHITE);
//  display.setCursor(x, y);
//}//end of preDisplay

// void timerIsr() {
//   digitalWrite(2, HIGH);
//   delay(100);
//   digitalWrite(2, LOW);
// }
